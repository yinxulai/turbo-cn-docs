import Callout from "../../../../components/Callout";

# 通过 Docker 部署

构建 [Docker](https://www.docker.com/) 镜像是部署各种应用程序的常用方法。 然而，从 monorepo 中这样做有几个挑战。

## 问题

**TL;DR:** 在 monorepo 中，不相关的更改会使 Docker 在部署应用程序时做不必要的工作。

假设您有一个如下所示的 monorepo：

```txt
├── apps
│   ├── docs
│   │   ├── server.js
│   │   └── package.json
│   └── web
│       └── package.json
├── package.json
└── package-lock.json
```

你想使用 Docker 部署 `apps/docs`，所以你创建了一个 Dockerfile：

```docker filename="Dockerfile"
FROM node:16

WORKDIR /usr/src/app

# Copy root package.json and lockfile
COPY package.json ./
COPY package-lock.json ./

# Copy the docs package.json
COPY apps/docs/package.json ./apps/docs/package.json

RUN npm install

# Copy app source
COPY . .

EXPOSE 8080

CMD [ "node", "apps/docs/server.js" ]
```

这会将 `root package.json` 和 `root lockfile` 复制到 docker 映像。然后，它将安装依赖项，复制应用程序源文件并启动应用程序。

您还应该创建一个 `.dockerignore` 文件以防止 node_modules 被复制到应用程序的源代码中。

```txt filename=".dockerignore"
node_modules
npm-debug.log
```

### lockfile 变动过于频繁

Docker 在部署应用程序方面非常聪明。 就像 Turbo 一样，它试图做 [尽可能少的工作](http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/)。

在我们的 Dockerfile 的例子中，它只会在它的镜像中的文件与之前的运行 _不同_ 时才会运行 `npm install`。如果没有，它将恢复之前的 `node_modules` 目录。

这意味着每当 `package.json`、`apps/docs/package.json` 或 `package-lock.json` 更改时，docker 映像将运行 `npm install`。

这听起来很棒——直到我们意识到一些事情。 `package-lock.json` 是 monorepo 的 _global_ 。 这意味着**如果我们在 `apps/web` 中安装一个新包，我们将导致 `apps/docs` 重新部署**。

在大型 monorepo 中，这可能会导致大量时间损失，因为对 monorepo 的锁定文件的任何更改都会级联成数十或数百次部署。

## 解决方案

解决方案是将 Dockerfile 的输入修剪为仅严格必要的输入。 Turborepo 提供了一个简单的解决方案 - `turbo prune`。

```bash
turbo prune --scope="docs" --docker
```

运行此命令会在 `./out` 目录中创建一个 **修剪过的 monorepo** 版本。 它只包括 `docs` 依赖的工作空间。

至关重要的是，它还**修剪 lockfile**，以便仅下载相关的 `node_modules`。

### `--docker` 标记

默认情况下，`turbo prune` 将所有相关文件放在 `./out` 中。 但是要使用 Docker 优化缓存，我们最好分两个阶段复制文件。

首先，我们只想复制安装软件包所需的内容。 运行 `--docker` 时，您会在 `./out/json` 中找到它。

```txt
out
├── json
│   └── apps
│       └── docs
│           └── package.json
├── full
│   └── apps
│       └── docs
│           ├── server.js
│           └── package.json
└── package-lock.json
```

之后，您可以复制 `./out/full` 中的文件以添加源文件。

以这种方式拆分**依赖项**和**源文件**让我们**仅在依赖项更改时运行`npm install`** - 给我们带来更大的加速。

<Callout type="info">
  如果没有 `--docker`，所有修剪过的文件都放在 `./out` 中。
</Callout>

### 示例

我们详细的 [`with-docker` 示例](https://github.com/vercel/turbo/tree/main/examples/with-docker) 深入探讨了如何充分利用 `prune` 的潜力。 这是 Dockerfile，为方便起见复制过来。

```docker
FROM node:alpine AS builder
RUN apk add --no-cache libc6-compat
RUN apk update
# Set working directory
WORKDIR /app
RUN yarn global add turbo
COPY . .
RUN turbo prune --scope=web --docker

# Add lockfile and package.json's of isolated subworkspace
FROM node:alpine AS installer
RUN apk add --no-cache libc6-compat
RUN apk update
WORKDIR /app

# First install the dependencies (as they change less often)
COPY .gitignore .gitignore
COPY --from=builder /app/out/json/ .
COPY --from=builder /app/out/yarn.lock ./yarn.lock
RUN yarn install

# Build the project
COPY --from=builder /app/out/full/ .
COPY turbo.json turbo.json
RUN yarn turbo run build --filter=web...

FROM node:alpine AS runner
WORKDIR /app

# Don't run production as root
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
USER nextjs

COPY --from=installer /app/apps/web/next.config.js .
COPY --from=installer /app/apps/web/package.json .

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=installer --chown=nextjs:nodejs /app/apps/web/.next/standalone ./
COPY --from=installer --chown=nextjs:nodejs /app/apps/web/.next/static ./apps/web/.next/static

CMD node apps/web/server.js
```
