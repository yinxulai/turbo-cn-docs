import { Tabs, Tab } from '../../../../components/Tabs'
import Callout from '../../../../components/Callout'

# Monorepo 中的开发任务

绝大多数开发工作流程如下所示：

1. 打开一个仓库
2. 在开发过程中运行一个 `dev` 任务
3. 在一天结束的时候，关闭 `dev` 任务并关闭存储库。

`dev` 可能是您的存储库中运行最频繁的任务，因此正确执行它很重要。

## `dev` 任务的类型

`dev` 任务有多种类型：

1. 为 Web 应用程序运行本地开发服务器
1. 每次代码发生更改时运行 [`nodemon`](https://www.npmjs.com/package/nodemon) 重新运行后端进程
1. 在 `--watch` 模式下运行测试

## 在 Turborepo 中配置

你应该在你的 `turbo.json` 中指定你的 `dev` 任务。

```json filename="turbo.json"
{
  "pipeline": {
    "dev": {
      "cache": false
    }
  }
}
```

由于 `dev` 任务不产生输出，`outputs` 是空的。 `dev` 任务的独特之处还在于您很少希望 [缓存](/repo/docs/core-concepts/caching) 它们，因此我们将 `cache` 设置为 `false`。

### 更新 `package.json`

你还应该在你的根 `package.json` 中提供一个 `dev` 任务：

```json filename="package.json"
{
  "scripts": {
    "dev": "turbo run dev"
  }
}
```

这使开发人员可以直接像他们往常一样从 package.json 运行任务。

## 运行 `dev` _之前_ 

在某些工作流程中，您需要在运行 `dev` 任务 _之前_ 运行一些任务。例如，`codegen` 或 `db:migrate` 任务。

在这些情况下，使用 [`dependsOn`](/repo/docs/core-concepts/running-tasks#in-the-same-workspace) 表示任何 `codegen` 或 `db:migrate` 任务都应该在运行 `dev`  _之前_ 运行。

```json filename="turbo.json"
{
  "pipeline": {
    "dev": {
      "dependsOn": ["codegen", "db:migrate"],
      "cache": false,
    },
    "codegen": {
      "outputs": ["./codegen-outputs/**"]
    },
    "db:migrate": {
      "cache": false
    }
  }
}
```

然后，在您应用的 `package.json` 中：

```json filename="apps/web/package.json"
{
  "scripts": {
    // For example, starting the Next.js dev server
    "dev": "next",
    // For example, running a custom code generation task
    "codegen": "node ./my-codegen-script.js",
    // For example, using Prisma
    "db:migrate": "prisma db push"
  }
}
```

这意味着执行 `dev` 任务的用户 _不需要担心 `codegen` 或 `db:migrate`_ — 甚至在他们的开发服务器启动之前就已经为他们处理好了。

## 仅执行特定的一些工作空间的 `dev` 命令

要仅在某些工作区中运行 `dev` 任务，您应该使用 [`--filter` 语法](/repo/docs/core-concepts/monorepos/filtering)。 例如：

```bash
turbo run dev --filter docs
```

只会在名为 `docs` 的工作区中运行 `dev`。

## 使用环境变量

在开发过程中，您经常需要使用环境变量。 这些允许您自定义程序的行为 - 例如，在开发和生产中指向不同的 `DATABASE_URL`。

我们建议使用名为 [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli) 的库来解决此问题。

### 教程

1. 在您的 [根工作区](/docs/handbook/what-is-a-monorepo#the-root-workspace) 中安装 `dotenv-cli`：

<Tabs items={['npm', 'yarn', 'pnpm']} storageKey="selected-pkg-manager">
  <Tab>
    ```bash
    # Installs dotenv-cli in the root workspace
    npm add dotenv-cli
    ```
  </Tab>
  <Tab>
    ```bash
    # Installs dotenv-cli in the root workspace
    yarn add dotenv-cli --ignore-workspace-root-check
    ```
  </Tab>
  <Tab>
    ```bash
    # Installs dotenv-cli in the root workspace
    pnpm add dotenv-cli --ignore-workspace-root-check
    ```
  </Tab>
</Tabs>

2. 将 `.env` 文件添加到您的根工作区：

```diff
  ├── apps/
  ├── packages/
+ ├── .env
  ├── package.json
  └── turbo.json
```

2. 添加您需要注入的任何环境变量：

```txt filename=".env"
DATABASE_URL=my-database-url
```

3. 在你的根 `package.json` 中，添加一个 `dev` 脚本。 使用 `dotenv` 和 `--` 参数分隔符作为前缀：

```json
{
  "scripts": {
    "dev": "dotenv -- turbo run dev"
  }
}
```

这将在运行 `turbo run dev` 之前从 `.env` 中提取环境变量。

4. 现在，您可以运行您的开发脚本：

<Tabs items={['npm', 'yarn', 'pnpm']} storageKey="selected-pkg-manager">
  <Tab>
    ```bash
    npm run dev
    ```
  </Tab>
  <Tab>
    ```bash
    yarn dev
    ```
  </Tab>
  <Tab>
    ```bash
    pnpm dev
    ```
  </Tab>
</Tabs>

您的环境变量将被填充！在 Node.js 中，这些在 `process.env.DATABASE_URL` 上可用。

<Callout>
  如果您使用它们来构建您的应用程序，您还应该 [添加您的环境变量](/docs/core-concepts/caching#altering-caching-based-on-environment-variables) 到您的 `turbo.json` 中。
</Callout>
